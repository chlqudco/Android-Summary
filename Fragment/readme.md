- Fragment
	- 얘도 마찬가지로 재사용과 상호작용을 촉진하기 위해 설계된 ..음.. 친구
	- 액티비티 내부에서 독립적으로 UI를 처리함
	- 앱이 실행될 때 UI를 동적으로 변경하기 위해 프래그먼트를 액티비티에 추가하거나 제거할 수 있다
	- 액티비티의 일부로만 사용될 수 있으며, 혼자서 독립적으로 실행되는 요소로는 생성될 수 없다
	
- 생성하기
	- 프래그먼트는 XML과 코틀린 파일로 구성된다
	- 여태했던 activity구성방식이랑 똑같
	- 코틀린 클래스는 반드시 Fragment()의 서브 클래스여야 한다
		- 과거 버전과의 호환성을 위해서는 FragmentActivity()를 상속받으면 됨
	- xml파일을 로드하기 위해 반드시 onCreateView()를 오버라이딩 해야한다
	- 프래그먼트를 액티비티에 바로 포함하려면 FragmentContainerView 를 이용
		- name 과 layout 속성을 잘 지정해야 한다.
		- 굳이 이렇게 안해도 됨
		- 런타임 시에 해당 프래그먼트를 제거할 수 없다는 단점이 생김

- 런타임시에 프래그먼트를 동적으로 제어하기 위해서는 프래그먼트를 코드에서 추가해야 한다
	- 이렇게 하면 동적으로 추가, 제거, 교체할 수 있다.
	- 코드를 사용해서 프래그먼트를 액티비티에 추가하는 표준 절차
	- 보통은 replace를 자주 쓰지 않나? 
```
supportFragmentManager.beginTransaction().add(
	R.id.레이아웃, 프래그먼트).commit()
```

- 프래그먼트 이벤트 처리
	- 프래그먼트도 당연히 이벤트를 발생시킬 수 있다.
	- 이벤트를 프래그먼트가 받을지, 포함하는 액티비티가 받을지는 핸들러 선언 방법에 달렸다
	- 리스너를 등록한지, onClick을 사용했는지에 따라 다름

- 프래그먼트 간의 통신
	- 통신은 프래그먼트를 토함하는 액티비티를 통해 이루어짐
	- 액티비티 -> 프래그먼트 통신 : 액티비티에서 id로 프래그먼트 객체를 확인한 뒤 프래그먼트 객체의 함수를 호출할 수 있다
	- 프래그먼트 -> 액티비티 통신 : 자신의 리스너 인터페이스를 정의하고 액티비티 클래스에 구현해야 한다.
		- 프래그먼트는 onAttach() 함수를 통해 전달 받을 수 있다.
		- 액티비티는 프래그먼트의 interface를 상속받아 구현해야 한다
		- 패캠에선 이렇게 안하지 않았나?

