- 자신이 시작된 스레드를 중단하지 않으면서 비동기적으로 실행되는 코드블록
	- 복잡한 구현이나 스레드 관리를 편리하게 해줌
	- 기존의 다중 쓰레드 방식보다 더 효율적이며 리소스를 적게 사용
	- 코드의 작성과 이해 및 유지보수가 훨씬 쉬워짐


- 디스패처
	- 코틀린은 서로 다른 유형의 비동기 작업 스레드를 유지, 관리한다
	- 코루틴을 시작할 때는 디스패처를 선택해야 함
		- Main : 메인쓰레드에서 코루틴을 실행
		- IO : 네트워크, 디스크, DB작업 코루틴에 적절
		- Default : CPU를 많이 쓰는 작업에 적합
	- 디스패처는 코루틴을 적합한 스레드에 할당하고 처리할 책임이 있다

- 코루틴 Scope
	- 모든 코루틴은 관리될 수 있는 범위에서 실행되어야 함
	- 코루틴을 취소 또는 소멸할 때 특히 중요함
		- 프래그먼트나 액티비티가 소멸될 때 이와 관련된 코루틴으로 인한 메모리 누수가 생기지 않게 해준다.
		- 다시 말해 앱에서 더이상 필요없는데도 백그라운드에서 계속 실행되는 것을 방지함
		- ex) 범위를 지정함으로써 한꺼번에 취소 가능
	- Global Scope : 최상위 수준의 코루틴을 시작하는데 사용
		- 사용하지 않는걸 권장
		- 구조화 되지 않은 동시실행
	- ViewModel Scope : 뷰모델 인스턴스에서 사용하기 위해 제공되는 범위
	- 이 외의 모든 경우에선 커스텀 Scope를 사용한다
		- ex) val scope = CoroutineScope(Dispatchers.Main)
	- 코루틴이 시작될 때는 항상 범위를 참조해야 한다

- suspend 함수
	- 코루틴은 실행되다가 일시 정지 할때 자신이 실행되던 스레드가 다른 코루틴에 할당된다.
	- 다시 실행을 재개할 때 사용 가능한 스레드를 코틀린 런타임이 다시 할당한다,
		- 효율적으로 스레드를 사용하기 위해
	- 이런 매커니즘에 맞춰 실행되게 해주는 함수가 suspend 함수
	- 함수 앞에 suspend를 쓰면 메인 스레드를 중단하지 않고 시간이 오래 걸리는 작업을 실행할 수 있다


- 코루틴 빌더
	- 앞의 모든 컴포넌트를 통합하고 코루틴을 실행함
	- launch : 코루틴 시작 및 결과 반한 안함
	- async : 코루틴 시작 및 결과 반환 가능
		- 호출 측에서 await()를 통해 결과를 기다릴 수 있다
		- 병행이 필요한 다수의 코루틴이 있을 때 사용
	- withContext
	 	- 부모와 다른 컨텍스트에서 코루틴 시작 가능
		- 코루틴 스코프 변경
	- runBlocking
		- 코루틴이 완료될 때까지 현재 스레드를 중단. 쓰지마셈

- 코루틴 VS 쓰레드
	- 스레드 : 리소스를 많이 씀
	- 코루틴 : 하나당 하나의 새 스레드 시작

- JOB
	- launch나 async 등의 빌더를 호출 하면 Job인스턴스 반환
	- 이 인스턴스로 코루틴의 생명주기 관리 가능

- 코루틴에서 결과 받기
	- 위에서 await() 쓰면 결과를 받을 수 있다고 말했음
	- 결과로 Deferred 객체를 반환해줌, Deferred<T>

- 채널
	- 채널을 통해 코루틴간의 통신을 구현할 수 있다.

- 1. 의존성 추가
	- implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1'
	- implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1'
